---
title: Why I'm now a fan of Tailwind CSS
subtitle: How utility-first CSS won me over.
date: 2020-12-14
tags:
  - css
  - front-end
---

## Some pros in favor of Tailwind

### Colocation of styles and markup

I'm a firm believer in organizing my projects with _colocation_ as the guiding principle. In short, colocation means that "files that change together should live together".

For example, you might organize your filesystem so that your unit tests and CSS files are located directly next to the code that they're testing.

```
└─ components
│     └─  Button.js
│     └─  Button.test.js
│     └─  Button.css
```

This approach has a number of benefits:

- Shorter file paths (bye, bye, `../../../../../`).
- Less digging thru the filesystem (everything you need is in the same folder).
- Deleting code becomes **waaaaay** simpler (just delete the whole folder).

Tailwind CSS takes this principle of colocation a step further—what if, instead of having CSS in an adjacent _file_, we put it in the HTML itself?

This means that we can lower the cognitive load _even more_ (less files to maintain). And when we delete the HTML (or JSX, template, etc), we automatically deleted the CSS.

<Callout>

_Tailwind isn't the only way to colocate styles with markup. `emotion`'s `css` prop and `theme-ui`'s `sx` prop both accomplish this in the CSS-in-JS world._

</Callout>

### No naming fatigue

A second quality of CSS-in-JS that I wasn't ready to sacrifice was removing the need to give every style a name.

Consider the following markup using BEM-style CSS classes.

```html
<div class="Card">
  <div class="Card--imageWrapper">
    <img class="Card--image" src="./potato.png" alt="potato" />
  </div>
  <div class="Card--content">
    <h2 class="Card--title">Potato</h2>
    <p class="Card--description">Yukon gold, 1lb bag</p>
  </div>
  <div class="Card--footer">
    <button class="Card--cta">Buy</button>
  </div>
</div>
```

If every HTML tag inside of this card markup needs some CSS, you have to come up with a CSS class name for every. single. HTML. tag.

And all that just so you can add `display: flex` to the bottom of the card footer.

Tailwind removes this need by moving the styles _into the markup itself_.

```html
<div class="p-4 bg-white">
  <div class="relative w-full h-12">
    <img class="absolute inset-0" src="./potato.png" alt="potato" />
  </div>
  <div class="p-4">
    <h2 class="text-xl">Potato</h2>
    <p class="text-l">Yukon gold, 1lb bag</p>
  </div>
  <div class="flex">
    <button class="text-white bg-blue-500">Buy</button>
  </div>
</div>
```

Naming things is a difficult yet important part of software development. It takes a lot of energy to come up with a good name that accurately conveys meaning yet isn't verbose.

Some things in your application aren't worth wasting energy naming. In my mind semantic CSS class names fall into this category. Tailwind lets you skip coming up with names for your markup and free yourself up to spend that energy on something else.

<Callout>

_In CSS-in-JS land, `emotion` also lets you skip naming things with the `css` prop, `theme-ui` does so with the `sx` prop._

</Callout>


### Constraint-based design

One of the large benefits to using CSS-in-JS over raw CSS or SCSS was setting up a design system based on _constraints_. In Emotion I would typically do this by setting up a _theme_ and populating that theme with all of my colors, spacings, font variants, etc.

Furthermore, in CSS-in-JS you could also set up _components_ to enforce your design constraints. The `Box` component from the [Braid Design System](TODO:) is an excellent example of a component that makes sure you use the design system.



<!-- Possible in CSS-in-JS thru creating _themes_ -->

## Benefits over CSS-in-JS

### No runtime JS

### Simpler build system (than CSS-in-JS)

<!-- Note about SSR especially -->

### "Bottom-up" abstractions

### Framework agnostic

## Addressing my (past) concerns

### bUt wHaT aBOut sEpArAtIOn oF cOnCErns?

### Ugly markup

### Big CSS file size

### Good for prototyping and small projects, but it won't scale.

### Not as dynamic as CSS-in-JS
