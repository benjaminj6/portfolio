---
title: TypeScript generics
# description:
date: 2020-09-11
tags:
  - typescript
---

## tl;dr ðŸ™ƒ

TypeScript generics allow you to make reusable type definitionsâ€”they work like **function parameters** by allowing parts of a type definition to be configurable.

## Overview: basic generic types ðŸ§±

Generics can be tough, especially when you're learning TypeScript for the first time. They're certainly more difficult than type annotations (`const a: number = 1`) or interfaces. 

Part of this is because generic types are **abstract types**. 

That plus the unfamiliar syntax (if you're coming from JavaScript) might have you wondering what the heck these `<>` brackets are doing all over the code. ðŸ˜±

To understand generics, let's consider a couple of type definitions for a blogging application.

```ts
interface User {
  id: string
  name: string
  email: string
  phoneNumber: string
}

interface Post {
  id: string
  userId: string
  title: string
  body: string
}
```

Now, let's think about data fetching in our fictional blogging application. Let's assume we have some standardized APIs that return lists of paginated data. The interfaces for the paginated API response could look something like this.

```ts
interface UsersListResponse {
  // Array of User objects
  data: User[]
  page: number
  totalPages: number
  totalCount: number
  perPage: number
}

interface PostsListResponse {
  // Array of Post objects
  data: Post[]
  page: number
  totalPages: number
  totalCount: number
  perPage: number
}
```

You'll notice that the `UsersListResponse` and the `PostsListResponse` are nearly identical. The only thing that isn't copy-pasta is the type of the `data` keyâ€”in one it's an array of `User` objects, in the other a`Post` array.

In this case we only have two interfacesâ€”it's not that difficult to keep them in sync. But as our applications grow we'll have more interfaces and we'll spend a bunch of time maintaining all the types to keep them synced.

TypeScript generics let us create a single source of truth for _types_.

Think of them like function paramaters, but for type definitions.

With generics, we can rewrite `UsersListResponse` and `PostsListResponse` to look like this.

```ts
interface PaginatedResponse<T> {
  data: T[]
  page: number
  totalPages: number
  totalCount: number
  perPage: number
}

type UsersListResponse = PaginatedResponse<User>
type PostsListResponse = PaginatedResponse<Post>
```

The _generic_ portion is the `<T>` in `PaginatedResponse<T>`â€”this basically sets up a type "argument" named `T`. We can then use `T` inside our interface to configure the _type_ of certain properties.

In this case we only want to configure `data` as a `T[]` since it's going to be an array of whatever type `T` is.

<Callout heading="Sidenote">

_You can name `T` anything you like. Using `T`, `U`, and `K` as generic parameter names is a convention you'll see a lot in TypeScript codeâ€”especially for simple interfaces. Think of `T` like using `i` as the `index` in a `for` loop._

</Callout>

Then, to create our two interfaces from before we can drop the `User` and `Post` types into the `<>` brackets on `PaginatedResponse`. So we end up with the exact same interface as before by doing `PaginatedResponse<User>`.

Leveraging these generic types allows us to easily respond to changes within our codebase in a type safe. For example, what if we added a new type of `Label` to the system? This is all we'd need on the TypeScript front.

```ts
interface Label {
  id: string
  name: string
  color: string
}

type LabelsListData = PaginatedResponse<Label>
```

## A deeper dive: advanced generic types 

I hope this small example has shown some of the ways that generic types can help in making your TypeScript code less verbose and more elegant! 

The above examples mainly covered the basic use case of generic types. In this section we'll get into a couple extra "tricks" we can use when using generics to make them even more useful. ðŸ’ª

### Constrained generic types

Sometimes we want to provide a generic type, but we don't want it to allow _any type_ as a parameter. Rather, we want to limit the parameter to a few approved types.

```ts
interface IndividualResponse<T extends object> {
  data: T
}

// âœ… This compiles correctly.
type UserByIdResponse = IndividualResponse<User>

// ðŸš¨ This gives the following compiler error:
// "Type 'number' does not satisfy the constraint 'object'."
type NumberResponse = IndividualResponse<number>
```

The type constraint is that `extends object` bit. I like to think of it as similar to typing a function argument.

```ts
const add = (a: number, b: number) => a + b
```

In this `add` function TypeScript doesn't care about what _values_ we pass into `a` and `b`. But it does throw compiler errors if those values aren't `number` types. In a similar way our `IndividualResponse` type will allow any _type_ as a parameter as long as it is an `object`. Since `number` isn't an `object` type, we get a compiler error.

### Default generic types

In the same way that we can provide a type constraint to an interface, we can also provide a **default type** when we're creating generics.

```ts
interface IndividualResponse<T = object> {
  data: object
}

const response: IndividualResponse = someData
const numberResponse: IndividualResponse<number> = someOtherData

// This will have a a type of "object"
response.data

// This will have a a type of "number"
numberResponse.data
```

It's usually a good idea to add some default type if you're planning on having your interfaces get reused a lot (unless you can _infer_ the type from a function parameterâ€”we'll get to that next). 

Lots of libraries use this approach in their type definitions because it gives you some default type safety out of the box without forcing you to use the `<>` syntax every time you use their API. And then if you want better type checking you can use the `<>` and pass your types in. Best of both worlds! ðŸ”¥

### Inferring generics from function parameters ðŸ¤¯

One of the most powerful ways to use TypeScript generics is to _infer_ their type from function parameters.

Consider this simplified version of the `Array.prototype.filter` function.

```ts
const filter = <T = unknown>(
  array: T[], 
  validate: (value: T, index: number) => boolean
) => {
  const newArray: T[] = []
  for (let i = 0; i < array.length; i++) {
    const value = array[i]
    const isValid = validate(value, i)

    if (isValid) {
      newArray.push(value)
    }
  }

  return newArray
}


const above3 = filter([1, 2, 3, 4, 5], number => number > 3) // Returns [4, 5]

above3 // Type is a "number[]"
```

That's definitely a big step up when it comes to confusing syntax. Let's look at just the type definition of `filter` and break down what's going on.

First, we have `<T = unknown>` right before the parentheses. This is the same as our `interface Name<T>`, just when we're typing a _function_ we put it right before the parentheses.

```ts
const filter = <T = unknown>(array, validate) => {
  // function body
}
```

Next, let's look at the `array` parameter to `filter`.

```ts
const filter = <T = unknown>(array: T[], validate) => {
  // function body
}
```

We're saying that whatever argument we pass as `array`, should be our dynamic type. This is actually enough for TypeScript to **infer** that when we call `filter([1, 2, 3, 4], value => value > 3)` that `array` will be a `number[]` and not something else!

But we can go a few steps further.

Let's take a look at the `validate` argument.

```ts
const filter = <T = unknown>(
  array: T[], 
  validate: (value: T, index: number) => boolean
) => {
  // function body
}
```

We can _also_ use `T` when typing our `validate` function to say that _whatever the type of the array is, the "value" should be the same type_!

This means that when we do `filter([1, 2, 3, 4], value => value > 3)` the compiler actually knows that `value => value > 3` should be a **number**. If we tried to do `value => value.toUpperCase()` (a string method) we'd get a compiler error. ðŸ”¥

Lastly, we can provide a little type hint when creating `newArray` to tell it that we're pushing items of type `T` into it.

```ts
const newArray: T[] = []
```

This seems like a lot of craziness. But it all comes together when we actually put our `filter` function into action.

```ts
const above3 = filter([1, 2, 3, 4, 5], value => value > 3)
```

You'll notice that this bit **doesn't have any types added**. It looks like plain old JavaScript.

But if we look at the type of `above3` in an IDE we'll see it's a `number[]`. In VSCode just hover over it and you'll see the types. Furthermore, hovering over `value` shows it's a `number` too. ðŸ”¥

Defining generic types this way can be difficult to get right. Chances are you'll struggle with the compiler your first few times.

But the reward is type safety without syntax clutter bleeding into other parts of your app. You drastically cut down on verbosity without sacrificing on type safety.

By typeing things this way you hide all the ugly TypeScript typings inside the **function**. That way people don't have to manually provide type every time they use `filter` in _their_ code.

## A warning about generics ðŸš§

As you can see, TypeScript generics can range from simple to ridiculously complex. It's easy for them to get out of hand if you're not careful.

Don't go overboard when creating generic typesâ€”a little duplication is way better than overengineering.

Remember that your TypeScript code is just a tool to help you write JavaScriptâ€”it's all going to get compiled down into JavaScript when you ship it. The type definitions are for _developers only_. 

And while a good developer experience does matter, it shouldn't come at the expense of shipping a good user experience.

Personally, I like to give a solid attempt to get generic typing working (~30 minutes). That's usually enough for me to figure out what's going on. But if I still can't get the generic type right I add `unknown` or `any` and continue with my work.

If getting generic types is difficult at first, keep trying! Like all programming concepts, it gets easier with practice.

---

## Resources

For some further reading on TypeScript generics, check out these resources. ðŸ¤“

- [Basarat's TypeScript Deep Dive](https://basarat.gitbook.io/typescript/type-system/generics)
- [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/generics.html#using-type-parameters-in-generic-constraints)
